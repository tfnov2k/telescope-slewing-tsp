# -*- coding: utf-8 -*-
"""2422814_ProagTanvee.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1qG1KAXg68cIGmP9unQ2bI0Ti3RUtWq6B

# **Optimizing Telescope Slewing through TSP using ACO**
Proag Tanvee, 2422814

Import libraries
"""

!pip install scikit-optimize

import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
import time
from time import perf_counter_ns, sleep
import random
from skopt import gp_minimize
from skopt.space import Real, Integer

"""**Data** - Read data from csv file and assign them to coordinates. Output the number of cities."""

# After uploading, read the CSV file directly from local storage
data = pd.read_csv('GaiaObservation_50.csv')

coordinates = data[['ra', 'dec']].to_numpy()
unique_points = data[['ra', 'dec']].drop_duplicates()
num_unique_points = unique_points.shape[0]
print(f"Number of unique points: {num_unique_points}")

"""**Calculate the Euclidean Distance**"""

def euclidean_distance(point1, point2):
    return np.sqrt((point1[0] - point2[0])**2 + (point1[1] - point2[1])**2)

"""**Greedy Search - Nearest Neighbour Heuristic**

---

It starts from the first city and repeatedly visits the nearest unvisited city and calculates the total distance traveled. Finally, it returns to the starting city, returns the path taken and the total distance.
"""

# Greedy Search
def greedy_tsp(data):
    n = len(data)
    visited = [False] * n
    path = []
    total_distance = 0

    # Start from the first city
    current_index = 0
    path.append(current_index)
    visited[current_index] = True

    for _ in range(1, n):
        nearest_distance = float('inf')
        nearest_index = None

        for j in range(n):
            if not visited[j]:
                distance = euclidean_distance(data[current_index], data[j])
                if distance < nearest_distance:
                    nearest_distance = distance
                    nearest_index = j

        total_distance += nearest_distance
        current_index = nearest_index
        path.append(current_index)
        visited[current_index] = True

    # Return to starting point
    total_distance += euclidean_distance(data[path[-1]], data[path[0]])

    return path, total_distance

"""**Ant Colony Optimization**

---

Three strategies: Max-Min Ant System (MMAS), Ant System (AS) and AS with elitism (ASElite)

A pheromone matrix is initialised. It guides the ants in their search for the shortest path. \\
At each iteratio, multiple ants explore the cities based on pheromone levels and heuristic information (the distances between cities). \\
After all ants have completed their tours, the distances of their paths are evaluated to identify the best solution found. Pheromone levels are updated based on the quality of the solutions. There is evaporation i.e. pheromone decay. \\
In MMAS, pheromone updates are restricted to the best solutions. AS updates pheromones based on all solutions. Elitism improves this by reinforcing paths taken by the top-performing ants. \\
The best and average distances over iterations are found to plot the graphs. It returns the best solution found, the best distance.


"""

def ant_colony(data, n_ants=500, n_iters=100, rho=0.8, alpha=1, beta=5, tau_min=0.00005, tau_max=5, mmas=True, n_elite=0):
    '''
    For traditional AS, set mmas as False and n_elite as 0
    For MMAS, set mmas as True and n_elite as 0
    For ASElite, set mmas as False and n_elite as > 0
    '''
    n = len(data)
    best_solution = None
    best_distance = float('inf')
    best_distances = []
    avg_distances = []

    #Find global bests for MMAS
    global_best_solution = None
    global_best_distance = float('inf')

    if mmas:
        pheromone_matrix = np.ones((n, n)) * tau_max  #For MMAS, Initialize with tau_max
    else:
        pheromone_matrix = np.ones((n, n))  #For AS, Initialize with 1

    #Simulating an ant's journey through a set of cities by selecting unvisited cities based on pheromone levels and heuristic information
    def solution():
        solution = []
        visited = set()
        current_city = random.randint(0, n - 1)
        solution.append(current_city)
        visited.add(current_city)

        while len(solution) < n:
            probabilities = []
            for j in range(n):
                if j not in visited:
                    pheromone = pheromone_matrix[current_city][j] ** alpha
                    heuristic = (1 / euclidean_distance(data[current_city], data[j])) ** beta
                    probabilities.append(pheromone * heuristic)
                else:
                    probabilities.append(0)
            total_probabilities = sum(probabilities)
            probabilities = [p / total_probabilities for p in probabilities]
            next_city = np.random.choice(range(n), p=probabilities)
            solution.append(next_city)
            visited.add(next_city)
            current_city = next_city

        return solution

    for iteration in range(n_iters):
        all_solutions = []
        all_distances = []

        #Construct solutions and calculate distances for all ants
        for _ in range(n_ants):
            sol = solution()
            distance = sum(euclidean_distance(data[sol[i]], data[sol[i + 1]]) for i in range(n - 1))
            distance += euclidean_distance(data[sol[-1]], data[sol[0]])  # Return to start

            all_solutions.append(sol)
            all_distances.append(distance)

            #Record the best solution
            if distance < best_distance:
                best_distance = distance
                best_solution = sol

        #Update the global best solution
        if best_distance < global_best_distance:
            global_best_solution = best_solution
            global_best_distance = best_distance

        #Pheromone evaporation
        pheromone_matrix *= rho

        if mmas:
            #Pheromone update using global and best solution
            for j in range(n - 1):
                pheromone_matrix[best_solution[j]][best_solution[j + 1]] += 1 / best_distance
                pheromone_matrix[global_best_solution[j]][global_best_solution[j + 1]] += 1 / global_best_distance
            pheromone_matrix[best_solution[-1]][best_solution[0]] += 1 / best_distance
            pheromone_matrix[global_best_solution[-1]][global_best_solution[0]] += 1 / global_best_distance

            #Pheromone levels are constrained within minimum and maximum bounds
            pheromone_matrix = np.clip(pheromone_matrix, tau_min, tau_max)

            # Pheromone perturbation every 10 iterations
            if iteration % 10 == 0:
                pheromone_matrix = np.clip(pheromone_matrix * (1 + np.random.uniform(-0.1, 0.1, pheromone_matrix.shape)), tau_min, tau_max)

        else:
            #AS - Update pheromones using all solutions
            for i in range(n_ants):
                for j in range(n - 1):
                    pheromone_matrix[all_solutions[i][j]][all_solutions[i][j + 1]] += 1 / all_distances[i]
                pheromone_matrix[all_solutions[i][-1]][all_solutions[i][0]] += 1 / all_distances[i]  # Return to start

            #ASElite - A few ants are 'elite'
            if n_elite > 0:
                elite_indices = np.argsort(all_distances)[:n_elite]  # Get indices of elite paths
                for index in elite_indices:
                    for j in range(n):
                        pheromone_matrix[all_solutions[index][j]][all_solutions[index][(j + 1) % n]] += (1 / all_distances[index])

        #Record best and average distances per iteration
        best_distances.append(best_distance)
        avg_distances.append(np.mean(all_distances))

    return best_solution, best_distance, best_distances, avg_distances

"""### Print the results
---
Set the parameters of the simulation. Print the time taken and best distance found for each strategy of ACO.
"""

print("AS TSP")
st = perf_counter_ns()
as_path, as_total_distance, as_best_distances, as_avg_distances = ant_colony(coordinates, n_ants=100, n_iters=80, rho=0.5, alpha=0.5, beta=1, tau_min=0, tau_max=0, mmas=False, n_elite=0)
et = perf_counter_ns()
print(as_total_distance, "<- Total distance traveled (parsecs)", )
print( (et - st) / 1_000_000_000, "<- Time taken (seconds)")

print("ASElite TSP")
n_elite_ants = int(0.25 * 500)  #Calculate number of elite ants as 25% of total ants
st = perf_counter_ns()
aselite_path, aselite_total_distance, aselite_best_distances, aselite_avg_distances = ant_colony(coordinates, n_ants=100, n_iters=80, rho=0.5, alpha=0.5, beta=1, tau_min=0, tau_max=0, mmas=False,n_elite=n_elite_ants)
et = perf_counter_ns()
print(aselite_total_distance, "<- Total distance traveled (parsecs)", )
print( (et - st) / 1_000_000_000, "<- Time taken (seconds)")

print("MMAS TSP")
st = perf_counter_ns()
mmas_path, mmas_total_distance, mmas_best_distances, mmas_avg_distances = ant_colony(coordinates, n_ants=100, n_iters=80, rho=0.5, alpha=0.5, beta=1, tau_min=0.0000005, tau_max=10, mmas=True, n_elite=0)
et = perf_counter_ns()
print(mmas_total_distance, "<- Total distance traveled (parsecs)", )
print( (et - st) / 1_000_000_000, "<- Time taken (seconds)")

"""### Plot the paths taken

Plot the paths taken by each strategy of ACO.
"""

plt.figure(figsize=(18, 6))

#Plot paths
def plot_path(ax, coordinates, path, title, color):
    ax.scatter(coordinates[:, 0], coordinates[:, 1], color='blue', label='Stars')
    for i in range(len(path)):
        ax.plot([coordinates[path[i-1]][0], coordinates[path[i]][0]],
                [coordinates[path[i-1]][1], coordinates[path[i]][1]], color=color)
    ax.set_title(title)
    ax.set_xlabel('Right Ascension (degrees)')
    ax.set_ylabel('Declination (degrees)')
    ax.grid(True)
    ax.legend()

# Plotting Greedy Path
ax1 = plt.subplot(1, 4, 1)
plot_path(ax1, coordinates, greedy_path, 'Greedy TSP Path', 'purple')

# Plotting ACO Path
ax2 = plt.subplot(1, 4, 2)
plot_path(ax2, coordinates, as_path, 'ACO TSP Path', 'green')

# Plotting MMAS Path
ax3 = plt.subplot(1, 4, 3)
plot_path(ax3, coordinates, mmas_path, 'MMAS TSP Path', 'red')

# Plotting ASElite Path
ax4 = plt.subplot(1, 4, 4)
plot_path(ax4, coordinates, aselite_path, 'ASElite TSP Path', 'yellow')

plt.tight_layout()
plt.show()

"""### Plot the convergence graph and the average distances graph

---

Plot the convergence graph to show exploitation and the average distances over iterations graph to show exploration.
"""

# Plotting convergence graphs
plt.figure(figsize=(12, 6))
plt.plot(as_best_distances, label='AS Best Distance', color='green')
plt.plot(mmas_best_distances, label='MMAS Best Distance', color='red')
plt.plot(aselite_best_distances, label='ASElite Best Distance', color='yellow')
plt.title('Convergence Graphs of AS and MMAS and ASElite')
plt.xlabel('Iterations')
plt.ylabel('Best Distance Found')
plt.legend()
plt.grid()
plt.show()

# Plotting average distances over iterations
plt.figure(figsize=(12, 6))
plt.plot(as_avg_distances, label='AS Average Distance', color='green', linestyle='--')
plt.plot(mmas_avg_distances, label='MMAS Average Distance', color='red', linestyle='--')
plt.plot(aselite_avg_distances, label='ASElite Average Distance', color='yellow', linestyle='--')
plt.title('Average Distance Over Iterations of AS and MMAS and ASElite')
plt.xlabel('Iterations')
plt.ylabel('Average Distance Found')
plt.legend()
plt.grid()
plt.show()

"""### Hyperparameter tuning using Bayesian Optimisation
---
The objective function takes a set of parameters and runs the algorithm with these parameters. It returns the total distance traveled by the best solution found which serves as the metric for optimization. \\
The space defines the ranges for each parameter to be optimized using Bayesian optimization \\
gp_minimize performs Bayesian optimization over the parameter space for a number of calls. The best parameters and corresponding minimum distance are extracted.\\
After obtaining the best parameters, the MMAS algorithm is executed again with these optimized parameters for 100 iterations. The total distance traveled and execution time are found. \\
The convergence plot shows the algorithm converges toward an optimal solution. \\
The average distance over iterations shows the performance of the algorithm during its execution.
"""

def objective(params):
    n_ants, rho, alpha, beta, tau_min, tau_max = params

    # Run ACO with provided parameters
    _, total_distance, _, _ = ant_colony(
        coordinates,
        n_ants=int(n_ants),
        n_iters=5,
        rho=rho,
        alpha=alpha,
        beta=beta,
        tau_min=tau_min,
        tau_max=tau_max,
        mmas=True
    )

    return total_distance

space = [
    Integer(50, 100),      # n_ants range
    Real(0.5, 1.0),        # rho range
    Real(1.0, 2.0),        # alpha range
    Real(1.0, 5.0),        # beta range
    Real(0, 0.5),          # tau_min range
    Real(5.0, 15.0)        # tau_max range
]

result = gp_minimize(objective,space,n_calls=10,random_state=1)

#Find best parameters and minimum distance
best_n_ants = int(result.x[0])
best_rho = result.x[1]
best_alpha = result.x[2]
best_beta = result.x[3]
best_tau_min = result.x[4]
best_tau_max = result.x[5]
minimum_distance = result.fun

#Print the best parameters found and the minimum distance
print("Best parameters found:")
print(f"n_ants: {best_n_ants}, rho: {best_rho}, alpha: {best_alpha}, beta: {best_beta}, tau_min: {best_tau_min}, tau_max: {best_tau_max}")
print(f"Minimum distance: {minimum_distance}")